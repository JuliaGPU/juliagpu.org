<!doctype html>
<html lang="en" class=h-100>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta content="index, follow" name=robots>
  <link rel="icon" href="/previews/PR23/assets/favicon.ico">
  <link rel="alternate" type="application/rss+xml" href="/previews/PR23/post/index.xml" title="RSS Feed for JuliaGPU">

  <link rel="stylesheet" href="/previews/PR23/css/bootstrap.min.css">
  
   <link rel="stylesheet" href="/previews/PR23/libs/highlight/github.min.css">
 

  <style>
 .hljs {
     padding: 0;
     background: 0 0
 }
.container {
   max-width: 700px
}

#nav-border {
   border-bottom: 1px solid #212529
}

#main {
   margin-top: 1em;
   margin-bottom: 4em
}

#home-jumbotron {
   background-color: inherit
}

#footer .container {
   padding: 1em 0
}

#footer a {
   color: inherit;
   text-decoration: underline
}

.font-125 {
   font-size: 125%
}

.tag-btn {
   margin-bottom: .3em
}

pre {
   background-color: #f5f5f5;
   border: 1px solid #ccc;
   border-radius: 4px;
   padding: 16px
}

pre code {
   padding: 0;
   font-size: inherit;
   color: inherit;
   background-color: transparent;
   border-radius: 0
}

code {
   padding: 2px 4px;
   font-size: 90%;
   color: #c7254e;
   background-color: #f9f2f4;
   border-radius: 4px
}

img,
iframe,
embed,
video,
audio {
   max-width: 100%
}

.card-img,
.card-img-top,
.card-img-bottom {
   width: initial
}

#main h1>a, #main h2>a, #main h3>a {
   color: inherit;
   text-decoration: none;
}

li p {
   margin: 0
}

</style>


  
  
    <title>Technical preview: Programming Apple M1 GPUs in Julia with Metal.jl ⋅ JuliaGPU</title>
  
</head>
<body class="d-flex flex-column h-100">
  <div id=nav-border class=container>
    <nav class="navbar navbar-expand-lg navbar-light justify-content-center">
        <ul class=navbar-nav>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/"><i data-feather=home></i>Home</a>
            </li>
            <li class="nav-item active"><a class=nav-link href="/previews/PR23/post/"><i data-feather=file-text></i>Blog</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/learn/"><i data-feather=book-open></i>Learn</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/cuda/">NVIDIA CUDA</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/rocm/">AMD ROCm</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/oneapi/">Intel oneAPI</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR23/other/">Other</a>
            </li>
        </ul>
    </nav>
</div>


  <div class="container">
    <main id=main>

    
      <!-- make sure to generate a Hugo-era URI at the root, redirecting to /post/.... -->
      

      <h1>Technical preview: Programming Apple M1 GPUs in Julia with Metal.jl</h1>
      <i data-feather=calendar></i>
<time datetime=2022-6-24>Jun 24, 2022</time><br>
<i data-feather=edit-2></i>
Tim Besard


      <br><br>
    
<!-- Content appended here -->

<p>Julia has gained a new GPU back-end: Metal.jl, for working with Apple&#39;s M1   GPUs. The back-end is built on the same foundations that make up existing   GPU packages like CUDA.jl and AMDGPU.jl, so it should be familiar to anybody   who&#39;s already programmed GPUs in Julia. In the following post I&#39;ll demonstrate   some of that functionality and explain how it works.</p>
<p>But first, note that <strong><a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a> is under heavy development</strong>: The package is considered experimental for now, as we&#39;re still working on squashing bugs and adding essential functionality. We also haven&#39;t optimized for performance yet. If you&#39;re interesting in using Metal.jl, please consider contributing to its development&#33; Most of the package is written in Julia, and checking-out the source code is a single <code>Pkg.develop</code> away :-&#41;</p>
<h2 id="quick_start"><a href="#quick_start" class="header-anchor">Quick start</a></h2>
<p>Start by getting a hold of the upcoming <a href="https://julialang.org/downloads/#upcoming_release">Julia 1.8</a>, launch it, and enter the package manager by pressing <code>&#93;</code>:</p>
<pre><code class="language-text">julia&gt; &#93;

pkg&gt; add Metal
  Installed Metal</code></pre>
<p>Installation is as easy as that, and we&#39;ll automatically download the necessary binary artifacts &#40;a C wrapper for the Metal APIs, and an LLVM back-end&#41;. Then, leave the package manager by pressing backspace, import the Metal package, and e.g. call the <code>versioninfo&#40;&#41;</code> method for some details on the toolchain:</p>
<pre><code class="language-text">julia&gt; using Metal

julia&gt; Metal.versioninfo&#40;&#41;
macOS 13.0.0, Darwin 21.3.0

Toolchain:
- Julia: 1.8.0-rc1
- LLVM: 13.0.1

1 device:
- Apple M1 Pro &#40;64.000 KiB allocated&#41;</code></pre>
<p>And there we go&#33; You&#39;ll note here that I&#39;m using the upcoming macOS 13 &#40;Ventura&#41;; this is currently the only supported operating system. We also only support M-series GPUs, even though Metal does support other GPUs. These choices were made to simplify development, and aren&#39;t technical limitations. In fact, Metal.jl <em>does</em> work on e.g. macOS Monterey with an Intel GPU, but it&#39;s an untested combination that may suffer from bugs.</p>
<h2 id="array_programming"><a href="#array_programming" class="header-anchor">Array programming</a></h2>
<p>Just like our other GPU back-ends, Metal.jl offers an array abstraction that greatly simplifies GPU programming. The abstraction centers around the <code>MtlArray</code> type that can be used to manage memory and perform GPU computations:</p>
<pre><code class="language-julia"># allocate &#43; initialize
julia&gt; a &#61; MtlArray&#40;rand&#40;Float32, 2, 2&#41;&#41;
2×2 MtlArray&#123;Float32, 2&#125;:
 0.158752  0.836366
 0.535798  0.153554

# perform some GPU-accelerated operations
julia&gt; b &#61; a * a
2×2 MtlArray&#123;Float32, 2&#125;:
 0.473325  0.261202
 0.167333  0.471702

# back to the CPU
julia&gt; Array&#40;b&#41;
2×2 Matrix&#123;Float32&#125;:
 0.473325  0.261202
 0.167333  0.471702</code></pre>
<p>Beyond these simple operations, Julia&#39;s higher-order array abstractions can be used to express more complex operations without ever having to write a kernel:</p>
<pre><code class="language-julia">julia&gt; mapreduce&#40;sin, &#43;, a; dims&#61;1&#41;
1×2 MtlArray&#123;Float32, 2&#125;:
 1.15276  0.584146

julia&gt; cos.&#40;a .&#43; 2&#41; .* 3
2×2 MtlArray&#123;Float32, 2&#125;:
 -2.0472   -1.25332
 -2.96594  -2.60351</code></pre>
<p>Much of this functionality comes from the <a href="https://github.com/JuliaGPU/GPUArrays.jl/">GPUArrays.jl</a> package, which provides vendor-neutral implementations of common array operations. As a result, <code>MtlArray</code> is already pretty capable, and should be usable with realistic array-based applications.</p>
<h2 id="kernel_programming"><a href="#kernel_programming" class="header-anchor">Kernel programming</a></h2>
<p>Metal.jl&#39;s array operations are implemented in Julia, using our native kernel programming capabilities and accompanying JIT-compiler. A small demonstration:</p>
<pre><code class="language-julia"># a simple kernel that sets elements of an array to a value
function memset_kernel&#40;array, value&#41;
  i &#61; thread_position_in_grid_1d&#40;&#41;
  if i &lt;&#61; length&#40;array&#41;
    @inbounds array&#91;i&#93; &#61; value
  end
  return
end

a &#61; MtlArray&#123;Float32&#125;&#40;undef, 512&#41;
@metal threads&#61;512 grid&#61;2 memset_kernel&#40;a, 42&#41;

# verify
@assert all&#40;isequal&#40;42&#41;, Array&#40;a&#41;&#41;</code></pre>
<p>As can be seen here, we&#39;ve opted to deviate slightly from the Metal Shading Language, instead providing a programming experience that&#39;s similar to Julia&#39;s existing back-ends. Some key differences:</p>
<ul>
<li><p>we use intrinsic functions instead of special kernel function arguments to access properties like the thread position, grid size, ...;</p>
</li>
<li><p>all types of arguments &#40;buffers, indirect buffers, value-typed inputs&#41; are transparently converted to a GPU-compatible structure<sup id="fnref:1"><a href="#fndef:1" class="fnref">[1]</a></sup>;</p>
</li>
<li><p>global &#40;task-bound&#41; state is used to keep track of the active device and a queue;</p>
</li>
<li><p>compute pipeline set-up and command encoding is hidden behind a single macro.</p>
</li>
</ul>
<p>Behind the scenes, we compile Julia to LLVM IR and use a <a href="https://github.com/JuliaGPU/llvm-metal">tiny LLVM back-end</a> &#40;based on <a href="https://github.com/a2flo">@a2flo</a>&#39;s <a href="https://github.com/a2flo/floor">libfloor</a>&#41; that &#40;re&#41;writes the bitcode to a Metal-compatible library containing LLVM 5 bitcode. You can inspect the generated IR using <code>@device_code_metal</code>:</p>
<pre><code class="language-julia">julia&gt; @device_code_metal @metal threads&#61;512 grid&#61;2 memset_kernel&#40;a, 42&#41;</code></pre>
<pre><code class="language-text">&#91;header&#93;
program_count: 1
...

&#91;program&#93;
name: julia_memset_kernel
type: kernel
...</code></pre>
<pre><code class="language-llvm">target datalayout &#61; &quot;...&quot;
target triple &#61; &quot;air64-apple-macosx13.0.0&quot;

; the &#40;rewritten&#41; kernel function:
;  - &#37;value argument passed by reference
;  - &#37;thread_position_in_grid argument added
;  - sitofp rewritten to AIR-specific intrinsic
define void @julia_memset_kernel&#40;
    &#123; i8 addrspace&#40;1&#41;*, &#91;1 x i64&#93; &#125; addrspace&#40;1&#41;* &#37;array,
    i64 addrspace&#40;1&#41;* &#37;value,
    i32 &#37;thread_position_in_grid&#41; &#123;
  ...
  &#37;9 &#61; tail call float @air.convert.f.f32.s.i64&#40;i64 &#37;7&#41;
  ...
  ret void
&#125;

; minimal required argument metadata
&#33;air.kernel &#61; &#33;&#123;&#33;10&#125;
&#33;10 &#61; &#33;&#123;void &#40;&#123; i8 addrspace&#40;1&#41;*, &#91;1 x i64&#93; &#125; addrspace&#40;1&#41;*,
              i64 addrspace&#40;1&#41;*, i32&#41;* @julia_memset_kernel, &#33;11, &#33;12&#125;
&#33;12 &#61; &#33;&#123;&#33;13, &#33;14, &#33;15&#125;
&#33;13 &#61; &#33;&#123;i32 0, &#33;&quot;air.buffer&quot;, &#33;&quot;air.location_index&quot;, i32 0, i32 1,
       &#33;&quot;air.read_write&quot;, &#33;&quot;air.address_space&quot;, i32 1,
       &#33;&quot;air.arg_type_size&quot;, i32 16, &#33;&quot;air.arg_type_align_size&quot;, i32 8&#125;
&#33;14 &#61; &#33;&#123;i32 1, &#33;&quot;air.buffer&quot;, &#33;&quot;air.location_index&quot;, i32 1, i32 1,
       &#33;&quot;air.read_write&quot;, &#33;&quot;air.address_space&quot;, i32 1,
       &#33;&quot;air.arg_type_size&quot;, i32 8, &#33;&quot;air.arg_type_align_size&quot;, i32 8&#125;
&#33;15 &#61; &#33;&#123;i32 0, &#33;&quot;air.thread_position_in_grid&quot;&#125;

; other metadata not shown, for brevity</code></pre>
<p>Shout-out to <a href="https://github.com/max-Hawkins">@max-Hawkins</a> for exploring Metal code generation during his internship at Julia Computing&#33;</p>
<h2 id="metal_apis_in_julia"><a href="#metal_apis_in_julia" class="header-anchor">Metal APIs in Julia</a></h2>
<p>Lacking an Objective C or C&#43;&#43; FFI, we interface with the Metal libraries using <a href="https://github.com/recp/cmt">a shim C library</a>. Most users won&#39;t have to interface with Metal directly – the array abstraction is sufficient for many – but more experienced developers can make use of the high-level wrappers that we&#39;ve designed for the Metal APIs:</p>
<pre><code class="language-julia">julia&gt; dev &#61; MtlDevice&#40;1&#41;
MtlDevice:
  name:             Apple M1 Pro
  lowpower:         false
  headless:         false
  removable:        false
  unified memory:   true

julia&gt; desc &#61; MtlHeapDescriptor&#40;&#41;
MtlHeapDescriptor:
  type:             MtHeapTypeAutomatic
  storageMode:      MtStorageModePrivate
  size:             0

julia&gt; desc.size &#61; 16384
16384

julia&gt; heap &#61; MtlHeap&#40;dev, desc&#41;
MtlHeap:
  type:                 MtHeapTypeAutomatic
  size:                 16384
  usedSize:             0
  currentAllocatedSize: 16384

# etc</code></pre>
<p>These wrappers are based on <a href="https://github.com/PhilipVinc">@PhilipVinc</a>&#39;s excellent work on MetalCore.jl, which formed the basis for &#40;and has been folded into&#41; Metal.jl.</p>
<h2 id="whats_next"><a href="#whats_next" class="header-anchor">What&#39;s next?</a></h2>
<p>The current release of Metal.jl focusses on code generation capabilities, and is meant as a preview for users and developers to try out on their system or with their specific GPU application. It is not production-ready yet, and is lacking some crucial features:</p>
<ul>
<li><p>performance optimization</p>
</li>
<li><p>integration with Metal Performance Shaders</p>
</li>
<li><p>integration / documentation for use with Xcode tools</p>
</li>
<li><p>fleshing out the array abstraction based on user feedback</p>
</li>
</ul>
<p><strong>Please consider helping out with any of these&#33;</strong> Since Metal.jl and its dependencies are almost entirely implemented in Julia, any experience with the language is sufficient to contribute. If you&#39;re not certain, or have any questions, please drop by the <code>#gpu</code> channel on <a href="https://julialang.org/slack/">the JuliaLang Slack</a>, ask questions on our <a href="https://discourse.julialang.org/c/domain/gpu/11">Discourse</a>, or chat to us during the <a href="https://julialang.org/community/#events">GPU office hours</a> every other Monday.</p>
<p>If you encounter any bugs, feel free to let us know on the <a href="https://github.com/JuliaGPU/Metal.jl/issues">Metal.jl issue tracker</a>. For information on upcoming releases, <a href="https://juliagpu.org/post/">subscribe</a> to this website&#39;s blog where we post about significant developments in Julia&#39;s GPU ecosystem.</p>
<hr />
<p><table class="fndef" id="fndef:1">
    <tr>
        <td class="fndef-backref"><a href="#fnref:1">[1]</a></td>
        <td class="fndef-content">This relies on Metal 3 from macOS 13, which introduced bindless argument</td>
    </tr>
</table>
      buffers, as we didn&#39;t fully figure out how to reliably encode       arbitrarily-nested indirect buffers in argument encoder metadata.</p>
<!-- CONTENT ENDS HERE -->
      </main>
    </div> <!-- class="container" -->


    
    
        <script src="/previews/PR23/libs/highlight/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    

    <footer id=footer class="mt-auto text-center text-muted">
        <div class=container>Made with <a href=https://franklinjl.org>Franklin.jl</a> and <a href=https://julialang.org>the Julia programming language</a>.</div>
    </footer>

    <!-- FEATHER -->
    <script src="/previews/PR23/libs/feather/feather.min.js"></script>
    <script>feather.replace()</script>

    <!-- GOOGLE ANALYTICS -->
    <script>
    window.ga = window.ga || function() {
        (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'UA-154489943-1', 'auto');
    ga('send', 'pageview');
    </script>
    <script async src=https://www.google-analytics.com/analytics.js></script>

  </body>
</html>
