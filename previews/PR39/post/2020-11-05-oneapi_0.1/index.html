<!doctype html>
<html lang="en" class=h-100>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no">
  <meta content="index, follow" name=robots>
  <link rel="icon" href="/previews/PR39/assets/favicon.ico">
  <link rel="alternate" type="application/rss+xml" href="/previews/PR39/post/index.xml" title="RSS Feed for JuliaGPU">

  <link rel="stylesheet" href="/previews/PR39/css/bootstrap.min.css">
  
   <link rel="stylesheet" href="/previews/PR39/libs/highlight/github.min.css">
 

  <style>
 .hljs {
     padding: 0;
     background: 0 0
 }
.container {
   max-width: 700px
}

#nav-border {
   border-bottom: 1px solid #212529
}

#main {
   margin-top: 1em;
   margin-bottom: 4em
}

#home-jumbotron {
   background-color: inherit
}

#footer .container {
   padding: 1em 0
}

#footer a {
   color: inherit;
   text-decoration: underline
}

.font-125 {
   font-size: 125%
}

.tag-btn {
   margin-bottom: .3em
}

pre {
   background-color: #f5f5f5;
   border: 1px solid #ccc;
   border-radius: 4px;
   padding: 16px
}

pre code {
   padding: 0;
   font-size: inherit;
   color: inherit;
   background-color: transparent;
   border-radius: 0
}

code {
   padding: 2px 4px;
   font-size: 90%;
   color: #c7254e;
   background-color: #f9f2f4;
   border-radius: 4px
}

img,
iframe,
embed,
video,
audio {
   max-width: 100%
}

.card-img,
.card-img-top,
.card-img-bottom {
   width: initial
}

#main h1>a, #main h2>a, #main h3>a {
   color: inherit;
   text-decoration: none;
}

li p {
   margin: 0
}

</style>


  
  
    <title>Introducing: oneAPI.jl ⋅ JuliaGPU</title>
  
</head>
<body class="d-flex flex-column h-100">
  <div id=nav-border class=container>
    <nav class="navbar navbar-expand-lg navbar-light justify-content-center">
        <ul class=navbar-nav>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/"><i data-feather=home></i>Home</a>
            </li>
            <li class="nav-item active"><a class=nav-link href="/previews/PR39/post/"><i data-feather=file-text></i>Blog</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/learn/"><i data-feather=book-open></i>Learn</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/cuda/">CUDA</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/rocm/">ROCm</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/oneapi/">oneAPI</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/metal/">Metal</a>
            </li>
            <li class="nav-item "><a class=nav-link href="/previews/PR39/other/">Other</a>
            </li>
        </ul>
    </nav>
</div>


  <div class="container">
    <main id=main>

    
      <!-- make sure to generate a Hugo-era URI at the root, redirecting to /post/.... -->
      

      <h1>Introducing: oneAPI.jl</h1>
      <i data-feather=calendar></i>
<time datetime=2020-11-5>Nov 5, 2020</time><br>
<i data-feather=edit-2></i>
Tim Besard


      <br><br>
    
<!-- Content appended here -->

<p>We&#39;re proud to announce the first version of oneAPI.jl, a Julia package for programming accelerators with the <a href="https://www.oneapi.com/">oneAPI programming model</a>. It is currently available for select Intel GPUs, including common integrated ones, and offers a similar experience to CUDA.jl.</p>
<p>The initial version of this package, v0.1, consists of three key components:</p>
<ul>
<li><p>wrappers for the oneAPI Level Zero interfaces;</p>
</li>
<li><p>a compiler for Julia source code to SPIR-V IR;</p>
</li>
<li><p>and an array interface for convenient data-parallel programming.</p>
</li>
</ul>
<p>In this post, I&#39;ll briefly describe each of these. But first, some essentials.</p>
<h2 id="installation"><a href="#installation" class="header-anchor">Installation</a></h2>
<p>oneAPI.jl is currently only supported on 64-bit Linux, using a sufficiently recent kernel, and requires Julia 1.5. Furthermore, it currently only supports a limited set of Intel GPUs: Gen9 &#40;Skylake, Kaby Lake, Coffee Lake&#41;, Gen11 &#40;Ice Lake&#41;, and Gen12 &#40;Tiger Lake&#41;.</p>
<p>If your Intel CPU has an integrated GPU supported by oneAPI, you can just go ahead and install the oneAPI.jl package:</p>
<pre><code class="language-julia">pkg&gt; add oneAPI</code></pre>
<p>That&#39;s right, no additional drivers required&#33; oneAPI.jl ships its own copy of the <a href="https://github.com/intel/compute-runtime">Intel Compute Runtime</a>, which works out of the box on any &#40;sufficiently recent&#41; Linux kernel. The initial download, powered by Julia&#39;s artifact subsystem, might take a while to complete. After that, you can import the package and start using its functionality:</p>
<pre><code class="language-julia-repl">julia&gt; using oneAPI

julia&gt; oneAPI.versioninfo&#40;&#41;
Binary dependencies:
- NEO_jll: 20.42.18209&#43;0
- libigc_jll: 1.0.5186&#43;0
- gmmlib_jll: 20.3.2&#43;0
- SPIRV_LLVM_Translator_jll: 9.0.0&#43;1
- SPIRV_Tools_jll: 2020.2.0&#43;1

Toolchain:
- Julia: 1.5.2
- LLVM: 9.0.1

1 driver:
- 00007fee-06cb-0a10-1642-ca9f01000000 &#40;v1.0.0, API v1.0.0&#41;

1 device:
- Intel&#40;R&#41; Graphics Gen9</code></pre>
<h2 id="the_onearray_type"><a href="#the_onearray_type" class="header-anchor">The <code>oneArray</code> type</a></h2>
<p>Similar to CUDA.jl&#39;s <code>CuArray</code> type, oneAPI.jl provides an array abstraction that you can use to easily perform data parallel operations on your GPU:</p>
<pre><code class="language-julia-repl">julia&gt; a &#61; oneArray&#40;zeros&#40;2,3&#41;&#41;
2×3 oneArray&#123;Float64,2&#125;:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; a .&#43; 1
2×3 oneArray&#123;Float64,2&#125;:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; sum&#40;ans; dims&#61;2&#41;
2×1 oneArray&#123;Float64,2&#125;:
 3.0
 3.0</code></pre>
<p>This functionality builds on the <a href="https://github.com/JuliaGPU/GPUArrays.jl/">GPUArrays.jl</a> package, which means that a lot of operations are supported out of the box. Some are still missing, of course, and we haven&#39;t carefully optimized for performance either.</p>
<h2 id="kernel_programming"><a href="#kernel_programming" class="header-anchor">Kernel programming</a></h2>
<p>The above array operations are made possible by a compiler that transforms Julia source code into SPIR-V IR for use with oneAPI. Most of this work is part of <a href="https://github.com/JuliaGPU/GPUCompiler.jl">GPUCompiler.jl</a>. In oneAPI.jl, we use this compiler to provide a kernel programming model:</p>
<pre><code class="language-julia-repl">julia&gt; function vadd&#40;a, b, c&#41;
           i &#61; get_global_id&#40;&#41;
           @inbounds c&#91;i&#93; &#61; a&#91;i&#93; &#43; b&#91;i&#93;
           return
       end

julia&gt; a &#61; oneArray&#40;rand&#40;10&#41;&#41;;

julia&gt; b &#61; oneArray&#40;rand&#40;10&#41;&#41;;

julia&gt; c &#61; similar&#40;a&#41;;

julia&gt; @oneapi items&#61;10 vadd&#40;a, b, c&#41;

julia&gt; @test Array&#40;a&#41; .&#43; Array&#40;b&#41; &#61;&#61; Array&#40;c&#41;
Test Passed</code></pre>
<p>Again, the <code>@oneapi</code> macro resembles <code>@cuda</code> from CUDA.jl. One of the differences with the CUDA stack is that we use OpenCL-style built-ins, like <code>get_global_id</code> instead of <code>threadIdx</code> and <code>barrier</code> instead of <code>sync_threads</code>. Other familiar functionality, e.g. to reflect on the compiler, is available as well:</p>
<pre><code class="language-julia-repl">julia&gt; @device_code_spirv @oneapi vadd&#40;a, b, c&#41;
; CompilerJob of kernel vadd&#40;oneDeviceArray&#123;Float64,1,1&#125;,
;                            oneDeviceArray&#123;Float64,1,1&#125;,
;                            oneDeviceArray&#123;Float64,1,1&#125;&#41;
; for GPUCompiler.SPIRVCompilerTarget

; SPIR-V
; Version: 1.0
; Generator: Khronos LLVM/SPIR-V Translator; 14
; Bound: 46
; Schema: 0
               OpCapability Addresses
               OpCapability Linkage
               OpCapability Kernel
               OpCapability Float64
               OpCapability Int64
               OpCapability Int8
          &#37;1 &#61; OpExtInstImport &quot;OpenCL.std&quot;
               OpMemoryModel Physical64 OpenCL
               OpEntryPoint Kernel
               ...
               OpReturn
               OpFunctionEnd</code></pre>
<h2 id="level_zero_wrappers"><a href="#level_zero_wrappers" class="header-anchor">Level Zero wrappers</a></h2>
<p>To interface with the oneAPI driver, we use the <a href="https://github.com/oneapi-src/level-zero">Level Zero API</a>. Wrappers for this API is available under the <code>oneL0</code> submodule of oneAPI.jl:</p>
<pre><code class="language-julia-repl">julia&gt; using oneAPI.oneL0

julia&gt; drv &#61; first&#40;drivers&#40;&#41;&#41;
ZeDriver&#40;00000000-0000-0000-1642-ca9f01000000, version 1.0.0&#41;

julia&gt; dev &#61; first&#40;devices&#40;drv&#41;&#41;
ZeDevice&#40;GPU, vendor 0x8086, device 0x1912&#41;: Intel&#40;R&#41; Graphics Gen9</code></pre>
<p>This is a low-level interface, and importing this submodule should not be required for the vast majority of users. It is only useful when you want to perform very specific operations, like submitting an certain operations to the command queue, working with events, etc. In that case, you should refer to the <a href="https://spec.oneapi.com/level-zero/latest/index.html">upstream specification</a>; The wrappers in the <code>oneL0</code> module closely mimic the C APIs.</p>
<h2 id="status"><a href="#status" class="header-anchor">Status</a></h2>
<p>Version 0.1 of oneAPI.jl forms a solid base for future oneAPI developments in Julia. Thanks to the continued effort of generalizing the Julia GPU support in packages like GPUArrays.jl and GPUCompiler.jl, this initial version is already much more usable than early versions of CUDA.jl or AMDGPU.jl ever were.</p>
<p>That said, there are crucial parts missing. For one, oneAPI.jl does not integrate with any of the vendor libraries like oneMKL or oneDNN. That means several important operations, e.g. matrix-matrix multiplication, will be slow. Hardware support is also limited, and the package currently only works on Linux.</p>
<p>If you want to contribute to oneAPI.jl, or run into problems, check out the GitHub repository at <a href="https://github.com/JuliaGPU/oneAPI.jl">JuliaGPU/oneAPI.jl</a>. For questions, please use the <a href="https://discourse.julialang.org/c/domain/gpu">Julia Discourse forum</a> under the GPU domain and/or in the #gpu channel of the <a href="https://julialang.org/community/">Julia Slack</a>.</p>
<!-- CONTENT ENDS HERE -->
      </main>
    </div> <!-- class="container" -->


    
    
        <script src="/previews/PR39/libs/highlight/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>

    

    <footer id=footer class="mt-auto text-center text-muted">
        <div class=container>Made with <a href=https://franklinjl.org>Franklin.jl</a> and <a href=https://julialang.org>the Julia programming language</a>.</div>
    </footer>

    <!-- FEATHER -->
    <script src="/previews/PR39/libs/feather/feather.min.js"></script>
    <script>feather.replace()</script>

    <!-- GOOGLE ANALYTICS -->
    <script>
    window.ga = window.ga || function() {
        (ga.q = ga.q || []).push(arguments)
    };
    ga.l = +new Date;
    ga('create', 'UA-154489943-1', 'auto');
    ga('send', 'pageview');
    </script>
    <script async src=https://www.google-analytics.com/analytics.js></script>

  </body>
</html>
