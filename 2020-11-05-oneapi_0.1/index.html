<!doctype html><html lang=en class=h-100><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta content="index, follow" name=robots><meta name=generator content="Hugo 0.75.1"><link rel=stylesheet href=https://juliagpu.org/css/bootstrap.min.css><link rel=stylesheet href=/highlight.css><script src=/highlight.min.js></script><script>hljs.initHighlightingOnLoad();</script><style>.hljs{padding:0;background:0 0}</style><title>Introducing: oneAPI.jl · JuliaGPU</title><style>.container{max-width:700px}#nav-border{border-bottom:1px solid #212529}#main{margin-top:1em;margin-bottom:4em}#home-jumbotron{background-color:inherit}#footer .container{padding:1em 0}#footer a{color:inherit;text-decoration:underline}.font-125{font-size:125%}.tag-btn{margin-bottom:.3em}pre{background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px;padding:16px}pre code{padding:0;font-size:inherit;color:inherit;background-color:transparent;border-radius:0}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}img,iframe,embed,video,audio{max-width:100%}.card-img,.card-img-top,.card-img-bottom{width:initial}</style></head><body class="d-flex flex-column h-100"><div id=nav-border class=container><nav class="navbar navbar-expand-lg navbar-light justify-content-center"><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/><i data-feather=home></i>Home</a></li><li class="nav-item active"><a class=nav-link href=/post/><i data-feather=file-text></i>Blog</a></li><li class=nav-item><a class=nav-link href=/learn/><i data-feather=book-open></i>Learn</a></li><li class=nav-item><a class=nav-link href=/cuda/>NVIDIA CUDA</a></li><li class=nav-item><a class=nav-link href=/rocm/>AMD ROCm</a></li><li class=nav-item><a class=nav-link href=/oneapi/>Intel oneAPI</a></li><li class=nav-item><a class=nav-link href=/other/>Other</a></li></ul></nav></div><div class=container><main id=main><h1>Introducing: oneAPI.jl</h1><i data-feather=calendar></i><time datetime=2020-11-05>Nov 5, 2020</time><br><i data-feather=edit-2></i>Tim Besard<br><br><p>We&rsquo;re proud to announce the first version of oneAPI.jl, a Julia package for programming
accelerators with the <a href=https://www.oneapi.com/>oneAPI programming model</a>. It is currently
available for select Intel GPUs, including common integrated ones, and offers a similar
experience to CUDA.jl.</p><p>The initial version of this package, v0.1, consists of three key components:</p><ul><li>wrappers for the oneAPI Level Zero interfaces;</li><li>a compiler for Julia source code to SPIR-V IR;</li><li>and an array interface for convenient data-parallel programming.</li></ul><p>In this post, I&rsquo;ll briefly describe each of these. But first, some essentials.</p><h2 id=installation>Installation</h2><p>oneAPI.jl is currently only supported on 64-bit Linux, using a sufficiently recent kernel,
and requires Julia 1.5. Furthermore, it currently only supports a limited set of Intel GPUs:
Gen9 (Skylake, Kaby Lake, Coffee Lake), Gen11 (Ice Lake), and Gen12 (Tiger Lake).</p><p>If your Intel CPU has an integrated GPU supported by oneAPI, you can just go ahead and
install the oneAPI.jl package:</p><pre><code>pkg&gt; add oneAPI
</code></pre><p>That&rsquo;s right, no additional drivers required! oneAPI.jl ships its own copy of the <a href=https://github.com/intel/compute-runtime>Intel
Compute Runtime</a>, which works out of the box on
any (sufficiently recent) Linux kernel. The initial download, powered by Julia&rsquo;s artifact
subsystem, might take a while to complete. After that, you can import the package and start
using its functionality:</p><pre><code class=language-julia-repl>julia&gt; using oneAPI

julia&gt; oneAPI.versioninfo()
Binary dependencies:
- NEO_jll: 20.42.18209+0
- libigc_jll: 1.0.5186+0
- gmmlib_jll: 20.3.2+0
- SPIRV_LLVM_Translator_jll: 9.0.0+1
- SPIRV_Tools_jll: 2020.2.0+1

Toolchain:
- Julia: 1.5.2
- LLVM: 9.0.1

1 driver:
- 00007fee-06cb-0a10-1642-ca9f01000000 (v1.0.0, API v1.0.0)

1 device:
- Intel(R) Graphics Gen9
</code></pre><h2 id=the-onearray-type>The <code>oneArray</code> type</h2><p>Similar to CUDA.jl&rsquo;s <code>CuArray</code> type, oneAPI.jl provides an array abstraction that you can
use to easily perform data parallel operations on your GPU:</p><pre><code class=language-julia-repl>julia&gt; a = oneArray(zeros(2,3))
2×3 oneArray{Float64,2}:
 0.0  0.0  0.0
 0.0  0.0  0.0

julia&gt; a .+ 1
2×3 oneArray{Float64,2}:
 1.0  1.0  1.0
 1.0  1.0  1.0

julia&gt; sum(ans; dims=2)
2×1 oneArray{Float64,2}:
 3.0
 3.0
</code></pre><p>This functionality builds on the <a href=https://github.com/JuliaGPU/GPUArrays.jl/>GPUArrays.jl</a>
package, which means that a lot of operations are supported out of the box. Some are still
missing, of course, and we haven&rsquo;t carefully optimized for performance either.</p><h2 id=kernel-programming>Kernel programming</h2><p>The above array operations are made possible by a compiler that transforms Julia source code
into SPIR-V IR for use with oneAPI. Most of this work is part of
<a href=https://github.com/JuliaGPU/GPUCompiler.jl>GPUCompiler.jl</a>. In oneAPI.jl, we use this
compiler to provide a kernel programming model:</p><pre><code class=language-julia-repl>julia&gt; function vadd(a, b, c)
           i = get_global_id()
           @inbounds c[i] = a[i] + b[i]
           return
       end

julia&gt; a = oneArray(rand(10));

julia&gt; b = oneArray(rand(10));

julia&gt; c = similar(a);

julia&gt; @oneapi items=10 vadd(a, b, c)

julia&gt; @test Array(a) .+ Array(b) == Array(c)
Test Passed
</code></pre><p>Again, the <code>@oneapi</code> macro resembles <code>@cuda</code> from CUDA.jl. One of the differences with the
CUDA stack is that we use OpenCL-style built-ins, like <code>get_global_id</code> instead of
<code>threadIdx</code> and <code>barrier</code> instead of <code>sync_threads</code>. Other familiar functionality, e.g. to
reflect on the compiler, is available as well:</p><pre><code class=language-julia-repl>julia&gt; @device_code_spirv @oneapi vadd(a, b, c)
; CompilerJob of kernel vadd(oneDeviceArray{Float64,1,1},
;                            oneDeviceArray{Float64,1,1},
;                            oneDeviceArray{Float64,1,1})
; for GPUCompiler.SPIRVCompilerTarget

; SPIR-V
; Version: 1.0
; Generator: Khronos LLVM/SPIR-V Translator; 14
; Bound: 46
; Schema: 0
               OpCapability Addresses
               OpCapability Linkage
               OpCapability Kernel
               OpCapability Float64
               OpCapability Int64
               OpCapability Int8
          %1 = OpExtInstImport &quot;OpenCL.std&quot;
               OpMemoryModel Physical64 OpenCL
               OpEntryPoint Kernel
               ...
               OpReturn
               OpFunctionEnd
</code></pre><h2 id=level-zero-wrappers>Level Zero wrappers</h2><p>To interface with the oneAPI driver, we use the <a href=https://github.com/oneapi-src/level-zero>Level Zero
API</a>. Wrappers for this API is available under the
<code>oneL0</code> submodule of oneAPI.jl:</p><pre><code class=language-julia-repl>julia&gt; using oneAPI.oneL0

julia&gt; drv = first(drivers())
ZeDriver(00000000-0000-0000-1642-ca9f01000000, version 1.0.0)

julia&gt; dev = first(devices(drv))
ZeDevice(GPU, vendor 0x8086, device 0x1912): Intel(R) Graphics Gen9
</code></pre><p>This is a low-level interface, and importing this submodule should not be required for the
vast majority of users. It is only useful when you want to perform very specific operations,
like submitting an certain operations to the command queue, working with events, etc. In
that case, you should refer to the <a href=https://spec.oneapi.com/level-zero/latest/index.html>upstream
specification</a>; The wrappers in the
<code>oneL0</code> module closely mimic the C APIs.</p><h2 id=status>Status</h2><p>Version 0.1 of oneAPI.jl forms a solid base for future oneAPI developments in Julia. Thanks
to the continued effort of generalizing the Julia GPU support in packages like GPUArrays.jl
and GPUCompiler.jl, this initial version is already much more usable than early versions of
CUDA.jl or AMDGPU.jl ever were.</p><p>That said, there are crucial parts missing. For one, oneAPI.jl does not integrate with any
of the vendor libraries like oneMKL or oneDNN. That means several important operations, e.g.
matrix-matrix multiplication, will be slow. Hardware support is also limited, and the
package currently only works on Linux.</p><p>If you want to contribute to oneAPI.jl, or run into problems, check out the GitHub
repository at <a href=https://github.com/JuliaGPU/oneAPI.jl>JuliaGPU/oneAPI.jl</a>. For questions,
please use the <a href=https://discourse.julialang.org/c/domain/gpu>Julia Discourse forum</a> under
the GPU domain and/or in the #gpu channel of the <a href=https://julialang.org/community/>Julia
Slack</a>.</p></main></div><footer id=footer class="mt-auto text-center text-muted"><div class=container>Made with <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/zwbetz-gh/vanilla-bootstrap-hugo-theme>Vanilla</a></div></footer><script src=https://juliagpu.org/js/feather.min.js></script><script>feather.replace()</script><script>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-154489943-1','auto');ga('send','pageview');</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>